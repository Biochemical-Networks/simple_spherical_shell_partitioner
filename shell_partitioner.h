#include <CGAL/Linear_cell_complex_for_combinatorial_map.h>
#include <CGAL/Polyhedron_3_to_lcc.h>
#include <CGAL/draw_linear_cell_complex.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Polyhedron_3.h>
#include <CGAL/convex_hull_3.h>

#include <vector>
#include <random>
#include <math.h>
#include <cmath>
#include <map>
#include <utility>

// Typedefs pertaining to the kernel
typedef CGAL::Exact_predicates_inexact_constructions_kernel  K;
typedef CGAL::Polyhedron_3<K>                     Polyhedron_3;
typedef K::Point_3                                Point_3;
// Typedefs pertaining to the convex hull LCC
typedef CGAL::Linear_cell_complex_for_combinatorial_map<2,3> LCC_CH;
typedef LCC_CH::Dart_handle           Dart_handle_CH;
// Typedefs pertaining to the shell LCC
typedef CGAL::Linear_cell_complex_for_combinatorial_map<3> LCC_3;
typedef LCC_3::Dart_handle           Dart_handle_3;
typedef LCC_3::Vertex_attribute_handle           Vertex_handle_3;
// Typedefs pertaining to maps and pairs
typedef std::map<Dart_handle_CH, Vertex_handle_3>   CHDH_to_VH3_map;
typedef std::map<Dart_handle_CH, Dart_handle_3>   CHDH_to_DH3_map;
typedef std::pair<CHDH_to_VH3_map,CHDH_to_VH3_map>   CHDH_to_VH3_pair;
typedef std::pair<std::vector<Dart_handle_3>, std::map<Dart_handle_3, Dart_handle_3>> inner_face_and_map;

/*
This computes the modulus of i % base but does so such that the result
is non-negative. This has utility for imposing periodicity in arrays/ vectors.
Since base % base = 0, the trick is to add base.
*/
int positive_modulo(int i, int base){
  return (base + (i % base)) % base;
}

/*
This function iterates over the vertex attributes for the convex hull
and prints out the points. This should be generalized to some sort of template.
*/
void print_vertices(LCC_CH &lcc){
  for (LCC_CH::Vertex_attribute_range::iterator
         it=lcc.vertex_attributes().begin(),
         itend=lcc.vertex_attributes().end();
       it!=itend; ++it)
  {
    std::cout<<"point: "<<lcc.point_of_vertex_attribute(it)<<std::endl;
  }
}

/*
This computes the circumcenter of the face containing the given dart.
*/
LCC_3::Point circumcenter(LCC_CH &chull, Dart_handle_CH &dh){
  // Get the points
  LCC_CH::Point a = chull.point(dh);
  LCC_CH::Point b = chull.point(chull.beta(dh,1));
  LCC_CH::Point c = chull.point(chull.beta(dh,0));
  // Compute the differences
  LCC_CH::Vector ba = b-a;
  LCC_CH::Vector ca = c-a;
  // Compute the cross products
  LCC_CH::Vector X = CGAL::cross_product(ba,ca);
  LCC_CH::Vector Xba = CGAL::cross_product(X,ba);
  LCC_CH::Vector Xca = CGAL::cross_product(X,ca);
  // Compute the circumcenter
  LCC_3::Point cc = a + (Xba*ca.squared_length()-Xca*ba.squared_length())/(2*X.squared_length());
  return cc;
}

/*
This generates a vector whose points are uniformly sampled from the sphere.
*/
std::vector<Point_3> random_spherical_points(int num_pts){
  // Create the container of points
  std::vector<Point_3> points;
  // Set up the random number generation
  std::mt19937 mt(time(NULL));
  double azi_angle, polar_angle;
  const double pi = 3.14159265;
  std::uniform_real_distribution<double> azimuthal_dist(-1.0,1.0);
  std::uniform_real_distribution<double> polar_dist(0.0,2*pi);
  // Randomly generate the points
  for(int i=0; i<num_pts; i++){
	  // Generate the angles, compute the coordinates, and store the point.
	  azi_angle = acos(azimuthal_dist(mt));
	  polar_angle = polar_dist(mt);
	  points.push_back(Point_3(sin(azi_angle)*cos(polar_angle),
			  sin(azi_angle)*sin(polar_angle), cos(azi_angle)));
  }
  return points;
}

/*
Computes the convex hull as a linear cell complex oriented clockwise
*/
LCC_CH make_chull(std::vector<Point_3> &points){
  // Declare the polyhedron and compute the convex hull
  Polyhedron_3 chull_polyhedron;
  CGAL::convex_hull_3(points.begin(), points.end(), chull_polyhedron);
  // Convert the polyhedron to a linear cell complex
  LCC_CH chull_lcc;
  Dart_handle_CH dh=CGAL::import_from_polyhedron_3<LCC_CH,Polyhedron_3>
    (chull_lcc, chull_polyhedron);
  // Check the orientation by computing the dot product between a cross product
  // generated by the ordered vertices of the face and the barycenter of that
  // face. Reverse the orientation if the dot product is positive.
  LCC_CH::Vector v1 = chull_lcc.point(chull_lcc.beta(dh,1))-chull_lcc.point(dh);
  LCC_CH::Vector v2 = chull_lcc.point(chull_lcc.beta(dh,0))-chull_lcc.point(dh);
  LCC_CH::Vector barycenter = chull_lcc.barycenter<2>(dh) - CGAL::ORIGIN;
  double signature = CGAL::cross_product(v1,v2)*barycenter;
  if(signature>0.0) chull_lcc.reverse_orientation();
  return chull_lcc;
}

/*
Given a convex hull LCC and a shell LCC, this uses duality to get the vertices of
the shell from the convex hull. It also establishes a pair of maps that send
darts on a face of the convex hull to the corresponding inner/ outer vertex of
the shell.
*/
CHDH_to_VH3_pair make_dual_vertices(LCC_CH &chull,
  LCC_3 &shell, double r_in, double r_out){
  // Declare the maps.
  CHDH_to_VH3_map inner_vertices;
  CHDH_to_VH3_map outer_vertices;
  // Iterate over one dart per face in chull
  for(LCC_CH::One_dart_per_cell_range<2>::iterator
    it=chull.one_dart_per_cell<2>().begin(), itend=chull.one_dart_per_cell<2>().end();
    it!=itend;++it){
      // Compute the projections of the dual point onto the inner and outer spheres
      // Can use the barycenter of the face
      //LCC_3::Vector center = chull.barycenter<2>(it) - CGAL::ORIGIN;
      // I find that I get better results with the circumcenter.
      LCC_3::Vector center = circumcenter(chull,it) - CGAL::ORIGIN;
      LCC_3::Point inner_point = CGAL::ORIGIN + (center * (r_in/std::sqrt(center.squared_length())));
      LCC_3::Point outer_point = CGAL::ORIGIN + (center * (r_out/std::sqrt(center.squared_length())));
      // Add the points to the vertex container and get their handles.
      Vertex_handle_3 inner_handle = shell.create_vertex_attribute<>(inner_point);
      Vertex_handle_3 outer_handle = shell.create_vertex_attribute<>(outer_point);
      // Iterate over the face and add the (dart, dual vertex) pairs to the
      // appropriate maps.
      Dart_handle_CH dh_start = it;
      Dart_handle_CH dh = it;
      do {
        inner_vertices[dh] = inner_handle;
        outer_vertices[dh] = outer_handle;
        dh = chull.beta(dh,1);
      } while (dh != dh_start);
  }
  // Make the pair of maps and export it.
  CHDH_to_VH3_pair map_pair = make_pair(inner_vertices, outer_vertices);
  return map_pair;
}

/*
The following function takes a convex hull LCC and a single dart from it, a
shell LCC with only vertex attributes and no darts, and a map from darts in
the convex hull to the vertex attributes in the shell. This makes the inner
and outer faces and updates a map that details how to glue the volumes. It
also returns a vector containing the darts in the inner face and a map from
darts in the inner face to the outer face.
*/
inner_face_and_map make_inner_outer_pair(LCC_CH &chull, Dart_handle_CH &dh_ch_start,
  LCC_3 &shell, CHDH_to_VH3_pair &map_pair, CHDH_to_DH3_map &glue_vol_map){
  // Create the vectors containing the darts for each face and the map between them.
  std::vector<Dart_handle_3> inner_face, outer_face;
  std::map<Dart_handle_3, Dart_handle_3> inner_outer_map;
  // Declare some handles
  Vertex_handle_3 inner_vh, outer_vh;
  Dart_handle_3 inner_dh, outer_dh;
  // Create a dart handle that will be used to iterate over the faces.
  Dart_handle_CH dh_ch = dh_ch_start;
  // Advance the faces until you've returned to the original one.
  do {
    // Get the vertex handles from the convex hull dart handle
    inner_vh = map_pair.first[dh_ch];
    outer_vh = map_pair.second[dh_ch];
    // Create the darts, push them into the vectors.
    inner_dh = shell.create_dart(inner_vh);
    inner_face.push_back(inner_dh);
    outer_dh = shell.create_dart(outer_vh);
    outer_face.push_back(outer_dh);
    // Add the appropriate entry to glue_vol_map
    glue_vol_map[chull.beta(dh_ch,0)]=inner_dh;
    // Get the dart incident to the same vertex at the next (clockwise) face
    dh_ch = chull.beta(dh_ch, 0, 2);
  } while (dh_ch != dh_ch_start);
  // We make the association between the darts... Scaling the destination
  // of the inner dart (by the ratio of the radii) gives the origin of the
  // corresponding outer dart. Sew the faces together as well.
  int vertices = inner_face.size();
  for(int i=0; i<vertices;++i){
    inner_outer_map[inner_face[i]] = outer_face[positive_modulo(i+1,vertices)];
    // The inner dart is sewn to the next clockwise dart.
    shell.sew<1>(inner_face[i], inner_face[positive_modulo(i+1,vertices)]);
    // The outer dart is sewn to the previous clockwise (next ccw) dart.
    shell.sew<1>(outer_face[i], outer_face[positive_modulo(i-1,vertices)]);
  }
  inner_face_and_map result = make_pair(inner_face, inner_outer_map);
  return result;
}

/*
This function takes the shell lcc, a vector containing the dart handles for
one inner face, and a map from darts on the inner face onto darts into the
outer face.
*/
void make_lateral_and_close(LCC_3 &shell, inner_face_and_map &inner_and_map_pair){
  // Extract the dart vector and map from the pair.
  std::vector<Dart_handle_3> inner_face = inner_and_map_pair.first;
  std::map<Dart_handle_3, Dart_handle_3> inner_outer_map = inner_and_map_pair.second;
  // Declare handles for the new darts
  Dart_handle_3 l1, l2, l3, l4;
  // Added the vertex handles explicitly for clarity
  Vertex_handle_3 vh1, vh2, vh3, vh4;
  // Loop over the vertices in the inner face
  int vertices = inner_face.size();
  for(int i=0; i<vertices; i++){
    // The dart 2-sewn to the inner dart starts at its destination.
    vh1 = shell.vertex_attribute(shell.beta(inner_face[i],1));
    l1 = shell.create_dart(vh1);
    // The dart after the new 2-sewn one has the same origin as the inner dart.
    vh2 = shell.vertex_attribute(inner_face[i]);
    l2 = shell.create_dart(vh2);
    // The dart 2-sewn to the outer dart starts at its destination.
    vh3 = shell.vertex_attribute(shell.beta(inner_outer_map[inner_face[i]],1));
    l3 = shell.create_dart(vh3);
    // The dart after the new 2-sewn one has the same origin as the outer dart.
    vh4 = shell.vertex_attribute(inner_outer_map[inner_face[i]]);
    l4 = shell.create_dart(vh4);
    // Two of the darts are 2-sewn, one to the inner dart, another to the outer.
    shell.sew<2>(inner_face[i], l1);
    shell.sew<2>(inner_outer_map[inner_face[i]],l3);
    // 1-sew the darts in the lateral face.
    shell.sew<1>(l1,l2);
    shell.sew<1>(l2,l3);
    shell.sew<1>(l3,l4);
    shell.sew<1>(l4,l1);
  }
  // Now we 2-sew the lateral faces together.
  for(int i=0; i<vertices; i++){
    l1 = shell.beta(inner_face[i],2,1);
    l2 = shell.beta(inner_face[i],0,2,0);
    shell.sew<2>(l1,l2);
  }
  return;
}

/*
This is to be used after the closed volumes have been formed. This 3-sews
them together.
*/
void glue_vols(LCC_CH &chull, LCC_3 &shell, CHDH_to_DH3_map &glue_vol_map){
  // Declare some handles for convenience.
  Dart_handle_CH dh_ch2;
  Dart_handle_3 dh_sh1, dh_sh2;
  // Iterate over one dart per edge in the convex hull.
  for(LCC_CH::One_dart_per_cell_range<1>::iterator
    dh_ch1=chull.one_dart_per_cell<1>().begin(), itend=chull.one_dart_per_cell<1>().end();
    dh_ch1!=itend;++dh_ch1){
      // Get the other dart corresponding to the edge in the convex hull.
      dh_ch2 = chull.beta(dh_ch1,2);
      // The glue_vol_map maps edges onto inner darts. To get the lateral
      // darts, you need to use beta_2.
      dh_sh1 = shell.beta(glue_vol_map[dh_ch1],2);
      dh_sh2 = shell.beta(glue_vol_map[dh_ch2],2);
      // 3-sew the darts together.
      shell.sew<3>(dh_sh1,dh_sh2);
  }
  return;
}

/*
This function puts everything together and uses duality to convert the convex
hull into a partition of the spherical shell.
*/
LCC_3 generate_shell(std::vector<Point_3> &points, double r_in, double r_out){
  // Declare the shell LCC and the map for gluing volumes/ 3-sewing
  LCC_3 shell;
  CHDH_to_DH3_map glue_vol_map;
  // Get the convex hull.
  LCC_CH chull = make_chull(points);
  // Make all of the vertices in the shell and get the map relating them to chull darts
  CHDH_to_VH3_pair chd_to_shv = make_dual_vertices(chull, shell, r_in, r_out);
  // Iterate over one dart per vertex in chull
  for(LCC_CH::One_dart_per_cell_range<0>::iterator
    it=chull.one_dart_per_cell<0>().begin(), itend=chull.one_dart_per_cell<0>().end();
    it!=itend;++it){
      // Given one dart per vertex in the convex hull, make the inner and outer
      // face, and get the pair containing the vector of inner darts and the
      // mapping of inner darts to outer ones.
      inner_face_and_map inner_and_map_pair = make_inner_outer_pair(chull, it, shell,
        chd_to_shv, glue_vol_map);
      // Make the lateral edges and close the volume.
      make_lateral_and_close(shell, inner_and_map_pair);
    }
    // Glue the volumes and return the result.
    glue_vols(chull, shell, glue_vol_map);
    return shell;
}

/*
This computes the center of mass of a face.
*/
LCC_3::Point face_center_of_mass(LCC_3 &lcc, Dart_handle_3 dh_start){
  LCC_3::Vector cumulative_sum = LCC_3::Vector(0.0,0.0,0.0);
  LCC_3::Vector diff = LCC_3::Vector(0.0,0.0,0.0);
  LCC_3::Point a, b;
  double perimeter = 0.0;
  Dart_handle_3 dh = dh_start;
  do {
    a = lcc.point(lcc.beta(dh,1));
    b = lcc.point(dh);
    diff = a-b;
    cumulative_sum += ((a-CGAL::ORIGIN)+(b-CGAL::ORIGIN))*0.5*std::sqrt(diff.squared_length());
    perimeter +=std::sqrt(diff.squared_length());
    dh = lcc.beta(dh,1);
  } while(dh != dh_start);
  LCC_3::Point center_of_mass = CGAL::ORIGIN + (cumulative_sum/perimeter);
  return center_of_mass;
}

/*
This triangulates all faces in a LCC_3 by inserting the center of mass. Caution
needs to be used. Inserting a point into a face creates more faces. You can't
naively iterate over faces, as this will reserve too many marks. Using a for loop
until it!=itend has the problem that itend is computed before faces are split.
You need to keep updating the size. You can either do this in the for loop or
use a while loop.
*/
void triangulate_all_faces(LCC_3 &lcc){
  // Reserve a mark
  LCC_3::size_type changed = lcc.get_new_mark();
  // Declare some dart handles and storage for the center of mass.
  Dart_handle_3 dh_start, dh;
  LCC_3::Point center_of_mass;
  // Loop over all darts until you reach the (changing) end.
  LCC_3::Dart_range::iterator it=lcc.darts().begin();
  while(it!=lcc.darts().end()){
    // Have we already visited this dart?
    if(!lcc.is_marked(it,changed)){
      // It belongs to a face we haven't divided yet. Split it.
      center_of_mass = face_center_of_mass(lcc,it);
      dh_start = lcc.insert_point_in_cell<2>(it, center_of_mass);
      dh = dh_start;
      // Mark all of the resulting faces belonging to the same volume as
      // dh_start
      while(!lcc.is_marked(dh,changed)){
        lcc.mark(dh,changed);
        lcc.mark(lcc.beta(dh,1),changed);
        lcc.mark(lcc.beta(dh,0),changed);
        dh = lcc.beta(dh,2,1);
      }
      // If dh_start is 3-sewn, we need to mark darts on the same face on
      // the other volume.
      if(!lcc.is_free<3>(dh_start)){
        dh = lcc.beta(dh_start,3,1);
        while(!lcc.is_marked(dh,changed)){
          lcc.mark(dh,changed);
          lcc.mark(lcc.beta(dh,1),changed);
          lcc.mark(lcc.beta(dh,0),changed);
          dh = lcc.beta(dh,2,1);
        }
      }
    }
    ++it;
  }
  // Unmark everything before returning!
  lcc.unmark_all(changed);
  lcc.free_mark(changed);
  return;
}

double get_lloyd_scalar(LCC_3 &lcc, Dart_handle_3 dh, int i){
  LCC_3::Point v0 = lcc.point(dh);
  LCC_3::Point v1 = lcc.point(lcc.beta(dh,1));
  LCC_3::Point v2 = lcc.point(lcc.beta(dh,0));
  double result = (v0[i]+v1[i]+v2[i])*(v0[i]+v1[i]+v2[i])
    - (v0[i]*v1[i]+v0[i]*v2[i]+v1[i]*v2[i]);
  return result;
}

LCC_3::Vector lloyd_single_face(LCC_3 &lcc, Dart_handle_3 dh){
  LCC_3::Point v0 = lcc.point(dh);
  LCC_3::Point v1 = lcc.point(lcc.beta(dh,1));
  LCC_3::Point v2 = lcc.point(lcc.beta(dh,0));
  LCC_3::Vector X = CGAL::cross_product(v1-v0,v2-v0);
  double c0 = get_lloyd_scalar(lcc, dh, 0);
  double c1 = get_lloyd_scalar(lcc, dh, 1);
  double c2 = get_lloyd_scalar(lcc, dh, 2);
  LCC_3::Vector contribution = LCC_3::Vector(c0*X[0],c1*X[1],c2*X[2]);
  return contribution;
}

std::vector<LCC_CH::Point> get_seeds_lloyd(LCC_3 &lcc){
  std::vector<LCC_CH::Point> new_seeds;
  LCC_CH::Point seed;
  LCC_CH::Vector lloyd_sum;
  // Iterate over volumes
  for(LCC_3::One_dart_per_cell_range<3>::iterator
    vol_it=lcc.one_dart_per_cell<3>().begin(), vol_end=lcc.one_dart_per_cell<3>().end();
    vol_it!=vol_end;++vol_it){
      // Reset seed.
      seed = LCC_CH::Point(0.0,0.0,0.0);
      lloyd_sum = LCC_CH::Vector(0.0,0.0,0.0);
      // Iterate over faces
      for(LCC_3::One_dart_per_incident_cell_range<2,3>::iterator
        face_it=lcc.one_dart_per_incident_cell<2,3>(vol_it).begin(),
        face_end=lcc.one_dart_per_incident_cell<2,3>(vol_it).end();
        face_it!=face_end; ++face_it){
          lloyd_sum += lloyd_single_face(lcc,face_it);
        }
      // Normalize, convert to point, then store.
      lloyd_sum = lloyd_sum/std::sqrt(lloyd_sum.squared_length());
      seed = CGAL::ORIGIN + lloyd_sum;
      new_seeds.push_back(seed);
    }
    return new_seeds;
}

void lloyd_relaxation(LCC_3 &lcc, int num_iter, double r_in, double r_out){
  std::vector<LCC_CH::Point> seeds;
  for(int i=0; i<num_iter; ++i){
    triangulate_all_faces(lcc);
    seeds = get_seeds_lloyd(lcc);
    lcc = generate_shell(seeds, r_in, r_out);
  }
  return;
}
