#include <CGAL/Linear_cell_complex_for_combinatorial_map.h>
#include <CGAL/Polyhedron_3_to_lcc.h>
#include <CGAL/draw_linear_cell_complex.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Polyhedron_3.h>
#include <CGAL/convex_hull_3.h>

#include <vector>
#include <random>
#include <math.h>
#include <cmath>
#include <map>
#include <utility>
//#include <algorithm>

/* // If you want to use exact constructions.
#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
typedef CGAL::Linear_cell_complex<3,3,
  CGAL::Linear_cell_complex_traits<3, CGAL::Exact_predicates_exact_constructions_kernel> > LCC_CH;
*/
typedef CGAL::Exact_predicates_inexact_constructions_kernel  K;
typedef CGAL::Polyhedron_3<K>                     Polyhedron_3;
typedef K::Point_3                                Poly_Point_3;

typedef CGAL::Linear_cell_complex_for_combinatorial_map<2,3> LCC_CH;
typedef LCC_CH::Dart_handle           Dart_handle_CH;
// typedef LCC_CH::Point                 Point_CH;
typedef CGAL::Linear_cell_complex_for_combinatorial_map<3> LCC_3;
typedef LCC_3::Dart_handle           Dart_handle_3;
typedef LCC_3::Vertex_attribute_handle           Vertex_handle_3;
typedef std::map<Dart_handle_CH, Vertex_handle_3>   CHDH_to_VH3_map;
typedef std::pair<CHDH_to_VH3_map,CHDH_to_VH3_map>   CHDH_to_VH3_pair;
typedef std::pair<std::vector<Dart_handle_3>, std::map<Dart_handle_3, Dart_handle_3>> inner_face_and_map;
// typedef LCC_3::Point                 Point_3;


int positive_modulo(int i, int base){
  return (n + (i % n)) % n;
}

/*
This function iterates over the vertex attributes for the convex convex hull
and prints out the points. This should be generalized to some sort of template.
*/
void print_vertices(LCC_CH &lcc){
  for (LCC_CH::Vertex_attribute_range::iterator
         it=lcc.vertex_attributes().begin(),
         itend=lcc.vertex_attributes().end();
       it!=itend; ++it)
  {
    std::cout<<"point: "<<lcc.point_of_vertex_attribute(it)<<std::endl;
  }
}

std::vector<Poly_Point_3> random_spherical_points(int num_pts){
  // Create the container of points
  std::vector<Poly_Point_3> points;
  // Set up the random number generation
  std::mt19937 mt(time(NULL));
  double azi_angle, polar_angle;
  const double pi = 3.14159265;
  std::uniform_real_distribution<double> azimuthal_dist(-1.0,1.0);
  std::uniform_real_distribution<double> polar_dist(0.0,2*pi);
  // Randomly generate the points
  for(int i=0; i<num_pts; i++){
	  // Generate the angles
	  azi_angle = acos(azimuthal_dist(mt));
	  polar_angle = polar_dist(mt);
	  points.push_back(Poly_Point_3(sin(azi_angle)*cos(polar_angle),
			  sin(azi_angle)*sin(polar_angle), cos(azi_angle)));
  }
  return points;
}

LCC_CH make_chull(std::vector<Poly_Point_3> &points){
  // Declare the polyhedron and compute the convex hull
  Polyhedron_3 chull_polyhedron;
  CGAL::convex_hull_3(points.begin(), points.end(), chull_polyhedron);
  // Convert the polyhedron to a linear cell complex
  LCC_CH chull_lcc;
  Dart_handle_CH dh=CGAL::import_from_polyhedron_3<LCC_CH,Polyhedron_3>
    (chull_lcc, chull_polyhedron);
  // Check the orientation by computing the dot product between a cross product
  // generated by the ordered vertices of the face and the barycenter of that
  // face. Reverse the orientation if the dot product is positive.
  LCC_CH::Vector v1 = chull_lcc.point(chull_lcc.beta(dh,1))-chull_lcc.point(dh);
  LCC_CH::Vector v2 = chull_lcc.point(chull_lcc.beta(dh,0))-chull_lcc.point(dh);
  LCC_CH::Vector barycenter = chull_lcc.barycenter<2>(dh) - CGAL::ORIGIN;
  double signature = CGAL::cross_product(v1,v2)*barycenter;
  if(signature>0.0) chull_lcc.reverse_orientation();
  return chull_lcc;
}

CHDH_to_VH3_pair make_dual_vertices(LCC_CH &chull,
  LCC_3 &shell, double r_in, double r_out){
  // Declare the maps.
  CHDH_to_VH3_map inner_vertices;
  CHDH_to_VH3_map outer_vertices;
  // Iterate over one dart per face in chull
  for(LCC_CH::One_dart_per_cell_range<2>::iterator
    it=chull.one_dart_per_cell<2>().begin(), itend=chull.one_dart_per_cell<2>().end();
    it!=itend;++it){
      // Compute the projections of the barycenter onto the inner and outer spheres
      LCC_CH::Vector bv = chull.barycenter<2>(it) - CGAL::ORIGIN;
      LCC_3::Point inner_point = CGAL::ORIGIN + (bv * (r_in/std::sqrt(bv.squared_length())));
      LCC_3::Point outer_point = CGAL::ORIGIN + (bv * (r_out/std::sqrt(bv.squared_length())));
      // Add the points to the vertex container and get their handles.
      Vertex_handle_3 inner_handle = shell.create_vertex_attribute<>(inner_point);
      Vertex_handle_3 outer_handle = shell.create_vertex_attribute<>(outer_point);
      // Iterate over the face and add the (dart, dual vertex) pairs to the
      // appropriate maps.
      Dart_handle_CH dh_start = it;
      Dart_handle_CH dh = it;
      do {
        inner_vertices[dh] = inner_handle;
        outer_vertices[dh] = outer_handle;
        dh = chull.beta(dh,1);
      } while (dh != dh_start);
  }
  // Make the pair of maps and export it.
  CHDH_to_VH3_pair map_pair = make_pair(inner_vertices, outer_vertices);
  return map_pair;
}

inner_face_and_map make_inner_outer_pair(LCC_CH &chull, Dart_handle_CH &dh_ch_start,
  LCC_3 &shell, CHDH_to_VH3_pair &map_pair, CHDH_to_VH3_map &glue_vol_map){
  // Create the vectors containing the darts for each face and the map between them.
  std::vector<Dart_handle_3> inner_face, outer_face;
  std::map<Dart_handle_3, Dart_handle_3> inner_outer_map;
  Vertex_handle_3 inner_vh, outer_vh;
  Dart_handle_3 inner_dh, outer_dh;
  Dart_handle_CH dh_ch = dh_ch_start;
  do {
    // Get the vertex handles
    inner_vh = map_pair.first[dh_ch];
    outer_vh = map_pair.second[dh_ch];
    // Create the darts, push them into the vectors.
    inner_dh = shell.create_dart(inner_vh);
    inner_face.push_back(inner_dh);
    outer_dh = shell.create_dart(outer_vh);
    outer_face.push_back(outer_dh);
    // Add the appropriate entry to glue_vol_map
    glue_vol_map[chull.beta(dh_ch,0)]=inner_dh;
    // Update the chull dart
    dh_ch = chull.beta(dh_ch, 0, 2);
  } while (dh_ch != dh_ch_start);
  // We make the association between the darts... Note that scaling the destination
  // of the inner dart gives the origin of the corresponding outer dart. Sew the
  // faces together as well.
  int vertices = inner_face.size();
  for(int i=0; i<vertices;++i){
    inner_outer_map[inner_face[i]] = outer_face[positive_modulo(i+1,vertices)];
    shell.sew<1>(inner_face[i], inner_face[positive_modulo(i+1,vertices)]);
    shell.sew<1>(outer_face[i], outer_face[positive_modulo(i-1,vertices)]);
  }
  inner_face_and_map result = make_pair(inner_face, inner_outer_map);
  return result;
}

void make_lateral_and_close(LCC_3 &shell, inner_face_and_map &inner_and_map){
  std::vector<Dart_handle_3> inner_face = inner_face_and_map.first;
  std::map<Dart_handle_3, Dart_handle_3> inner_outer_map = inner_face_and_map.second;
  int vertices = inner_face.size();
  Dart_handle_3 l1, l2, l3, l4;
  for(int i=0; i<vertices; i++){
    l1 = shell.create_dart(shell.vertex_attribute(shell.beta(inner_face[i],1)));
    l2 = shell.create_dart(shell.vertex_attribute(inner_face[i]));
    l3 = shell.create_dart(shell.vertex_attribute(shell.beta(inner_outer_map[inner_face[i]],1)));
    l4 = shell.create_dart(shell.vertex_attribute(inner_outer_map[inner_face[i]]));
    shell.sew<2>(inner_face[i], l1);
    shell.sew<2>(inner_outer_map[inner_face[i]],l3);
    shell.sew<1>(l1,l2);
    shell.sew<1>(l2,l3);
    shell.sew<1>(l3,l4);
    shell.sew<1>(l4,l1);
  }
  for(int i=0; i<vertices; i++){
    l1 = shell.beta(inner_face[i],2,1);
    l2 = shell.beta(inner_face[i],0,2,0);
    shell.sew<2>(l1,l2);
  }
  return;
}

void glue_vols(LCC_CH &chull, LCC_3 &shell, CHDH_to_VH3_map &glue_vol_map){
  Dart_handle_CH dh_ch2;
  Dart_handle_3 dh_sh1, dh_sh2;
  for(LCC_CH::One_dart_per_cell_range<1>::iterator
    dh_ch1=chull.one_dart_per_cell<1>().begin(), itend=chull.one_dart_per_cell<2>().end();
    dh_ch1!=itend;++dh_ch1){
      dh_ch2 = chull.beta(dh_ch1,2);
      dh_sh1 = shell.beta(glue_vol_map[dh_ch1],2);
      dh_sh2 = shell.beta(glue_vol_map[dh_ch2],2);
      shell.sew<3>(dh_sh1,dh_sh2);
  }
  return;
}
